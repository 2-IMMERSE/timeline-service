Timeline document format
========================

The document format is inspired by SMIL, but cut down to an absolute minimum,
and fixing various issues I think exist with SMIL.

Requirements
------------

What I want to keep:

- hierarchical containment
- automatic inference of timing
- parallel and sequential composition
- conditional composition

What I want to get rid of, and why:

- layout. This should be left to CSS or the host language or whatever.
- human-friendly format. As most documents will be generated by software there
  is no real reason for _convenience features_ for humans that muddle the
  semantics.
- Anything not directly related to timing: animations, transitions, SMIL state,
  etc. The language should have hooks for driving this functionlity, but no more.
- XML dependency. Probably XML is going to be the standard external
  representation, but I want to be able to also represent  documents in JSON or
  in a palatable in-core object format. This should help palatability to the
  Javascript community.

What I want to gain:

- Serializability of current state. After a document has been playing back for
  some time it be able to save it so that when this new document starts playing
  it starts exactly where it was when it was saved.
- Timegraph equivalence. The document, when running, must be its own timegraph.
  This may be the same requirement as the previous one, seen from a different
  angle.
- Editability. It must be possible to modify the document (and hence the
  timegraph) while the document is running. I think it is enough to specify the
  semantics the following operations:
	* delete element (and its complete subtree)
	* insert child element
	* insert parent element
- Timing and synchronization semantics that can be explained in about one page
  of text.

Design
------

I'll use XML-centric language here, but wherever I say "element" you could also
read "object" (and where I say "attribute" you could read "instance variable").
I will also use the "tl:" XML namespace, just to make clear that the element
may have lots of other attributes but these are irrelevant to the timing
semantics of the document.

Every element should do one thing, and one thing only. The only attributes the
element has are those that are vital to the semantics of the element. This should
lead to an enormous simplification of semantics (when compared to SMIL) because
there is no more need to explain interplay between attributes (such as for SMIL
end/dur/repeatDur/repeatCount/fill). It should also help serializability.

Every element has a virtual clock. This clock may be independent (either from
a media clock derived from whether audio or video it is playing, or from a wall
clock) or it can be slaved to the clock of its parent or one of its children.

If the virtual clock of a media element is slaved to the clock of its parent then
the media clock should follow the virtual clock, so media playback may need to
speed up or slow down (or skip or pause) to resynchronise. We will probably
need a couple of attributes eventually to state how this should be done, but
the coupling of the virtual clock to the media clock is a purely local effect
and does not affect the timegraph.

Timing and synchronisation relationships only exist between parents and children.
There is no synchronisation between sibling elements, formally, this all goes
via the parent. But, practically speaking, normally a parent will pick up its
clock from one of its children, and slave the clocks of its other children.
When compared to SMIL we do lose the ability to specify out-of-tree
synchronisation requirements, such as for SMIL syncBase.

Virtual clocks have a priority, and the idea is that a `<tl:par>` element picks
up the clock from its highest priority child or from its parent.
It then uses this clock to drive the other children (or its parent). This
relationship is dynamic, so as children start and stop different clocks can become
the master. 

These simplified clock and synchronisation designs should enable editability, and
again help with serializability and simplified semantics.


Format
------

`<tl:ref tl:prio="100" tl:fill="freeze|remove">`

Media element. Whether this is actually called `tl:ref` or something else (such
as a `tl:video`, `tl:audio`, `tl:script` etc) remains to be seen. It could even be that there
is no element as such but an attribute on an element in the host language (for
example `tl:timeAction="none|visibility|display|..."` as per HTML+SMIL). The `tl:prio`
is used by a `tl:par` parent (or actually closest `tl:par` ancestor) to
determine clock priorities and select the master clock. `tl:fill` is used by
the `tl:par` parent or ancestor to determine what to do when a non-master element
ends while the master element clock is still running: either pause it or remove it.

`<tl:par tl:end="first|all|master" tl:sync="true|false" tl:prio=... tl:fill=...>`

Parallel composition. All children run in parallel. The end of the `tl:par`
depends on the `tl:end` attribute: either when the first of its children has ended,
the last of its children has ended or its timeline master child has ended. We may
also want to specify a specific child (by xmlid) to determine when the `tl:par`
ends.

*Note* (20160805): `tl:end="master"` may not be such a good idea. The master needs to be
computed dynamically (because it is used for clock synchronisation), but obviously
when the child-previously-known-as-master has stopped it is now no longer master.
Need to think about this a bit more.

`tl:sync` determines whether the children (except the master) are synchronised
to the `tl:par`, or whether they are free-running. The latter essentially creates
a completely independent timeline.

It may be better to move the functionality of the `tl:sync` attribute to the child node,
so it is possible to easily specify that most children of a par are synchronised but
some are running on an independent timeline. Then we would get something like a
`tl:independent="true|false"` attribute. But it would only be allowed inside a
`tl:par` parent...

`<tl:seq>`

Sequential composition. The children run one after the other. I think `tl:seq` should
not have the `tl:prio` and `tl:fill` attributes, but I am not quite sure.

`<tl:sleep tl:dur="10s" />`

Do nothing. Stop running after the given `tl:dur`.

`<tl:wait tl:event="...." />`

Do nothing. Stop running when the event happens. How this event is specified
(and whether we need the `tl:event` parameter in the first place) remains to
be seen, and probably depends on the host language.

`<tl:conditional tl:expr="...">`

Conditionally run the single child, based on whether `tl:expr` evaluates to true
or not. This may be better specified as an attribute (so we don't have this
_single child_ requirement). Language for the expression is to be determined.

`<tl:excl>` and `<tl:switch>`

We may want some form of exclusives but this remains to be determined.

`<tl:repeat ...>`

We probably want some way to repeat things.

Examples
--------

Various constructs become quite a bit more convoluted in this language than they
are in SMIL. First and foremost, not having `begin`, `dur` and `end` attributes means
that `<video begin="5s" dur="10s" .../>` will have to be encoded as

```
<tl:par tl:end="first">
  <tl:seq>
    <tl:sleep tl:dur="5s"/>
    <tl:video .../>
  </tl:seq>
  <tl:sleep tl:dur="10s"/>
</tl:par>
```

This is a nuisance from a coding point of view, but it has a great advantage for
the semantics. For example, it is absolutely clear that the "5s" is not with
respect to the video clock, and the 10s may be (depending on clock priorities).

API
---

There is going to be some sort of an API between the objects (at runtime),
specifically between parents and children. From parent to child, there will
be some sequence of `init()/start()/stop()/pause()/resume()`, and some
calls to modify clock relationships `slaveClockToMe()/becomeMasterClock()`.
There will be some callbacks from child to parent `inited()/started()/stopped()/paused()/resumed()`
and some callbacks between clock master and clock slave `clockChanged()`.
There needs to be a call to get the current time of an element.

*Note* (20160805): we may need another state between started and stopped
that is similar to SMIL `fill="freeze"`, or alternatively a state `terminated`
plus an accompanying call `terminate()`. Otherwise freeze semantics seem difficult 
to implement. State `stopped` would then mean that the timeline of the object
has run to completion, but the object is still visible. A call to `terminate()`
would then be needed to remove it. And need to think whether `terminate()`
implies `stop()`, etc.

