Timeline document format
========================

The document format is inspired by SMIL, but cut down to an absolute minimum,
and fixing various issues I think exist with SMIL. 

The document format is
intended to be long lived and applicable to multiple application areas, but
this description is somewhat tailored to the first application area: the
2immerse timeline server, which orchestrates media objects running on multiple
devices (think handhelds and TVs), to allow creation of a single unified experience
for the viewers.

Requirements
------------

What SMIL aspects I want to keep:

- hierarchical containment
- automatic inference of timing
- parallel and sequential composition
- conditional composition

What SMIL things I want to get rid of, and why:

- layout. This should be left to CSS or the host language or whatever.
- human-friendly format. As most documents will be generated by software there
  is no real reason for _convenience features_ for humans, because they will muddle the
  semantics.
- Anything not directly related to timing: animations, transitions, SMIL state,
  etc. The language should have hooks for driving this functionality, but no more.
- XML dependency. Probably XML is going to be the standard external
  representation, but I want to be able to also represent  documents in JSON or
  in a palatable in-core object format. This should help acceptability to the
  Javascript community.

What I want to gain:

- Serializability of current state. After a document has been playing back for
  some time it must be possible to save it in such a way that when this new 
  document starts playing it starts exactly where it was when it was saved.
- Timegraph equivalence. The document, when running, must be its own timegraph.
  This may be the same requirement as the previous one, seen from a different
  angle.
- Editability. It must be possible to modify the document (and hence the
  timegraph) while the document is running. I think it is enough to specify the
  semantics the following operations:
	* delete element (and its complete subtree)
	* insert child element
	* insert parent element
- Timing and synchronization semantics that can be explained in about one page
  of text.
  
Applications:

The first application to which this format has been applied is the 2immerse timeline
server. 2immerse-specific details are in a section below.

Design
------

I'll use XML-centric language here, but wherever I say "element" you could also
read "object" (and where I say "attribute" you could read "instance variable").
I will also use the "tl:" XML namespace, just to make clear that the element
may have lots of other attributes but these are irrelevant to the timing
semantics of the document.

Every element should do one thing, and one thing only. The only attributes the
element has are those that are vital to the semantics of the element. This should
lead to an enormous simplification of semantics (when compared to SMIL) because
there is no more need to explain interplay between attributes (such as for SMIL
end/dur/repeatDur/repeatCount/fill). It should also help serializability.

Every element has a virtual clock. This clock may be independent (either from
a media clock derived from whatever audio or video stream it is playing, or from a wall
clock) or it can be slaved to the clock of its parent or one of its children.

If the virtual clock of a media element is slaved to the clock of its parent then
the media clock should follow the virtual clock, so media playback may need to
speed up or slow down (or skip or pause) to resynchronise. We will probably
need a couple of attributes eventually to state how this should be done, but
the coupling of the virtual clock to the media clock is a purely local effect
and does not affect the timegraph.

Timing and synchronisation relationships only exist between parents and children.
There is no synchronisation between sibling elements, formally, this all goes
via the parent. But, practically speaking, normally a parent will pick up its
clock from one of its children, and slave the clocks of its other children.
When compared to SMIL we do lose the ability to specify out-of-tree
synchronisation requirements, such as for SMIL `syncBase`.

Virtual clocks have a priority, and the idea is that a `<tl:par>` element picks
up the clock from its highest priority child or from its parent.
It then uses this clock to drive the other children (or its parent). This
relationship is dynamic, so as children start and stop different clocks can become
the master. 

These simplified clock and synchronisation designs should enable editability, and
again help with serializability and simplified semantics.


Format
------

`<tl:ref tl:prio="100" tl:fill="freeze|remove">`

Media element. Whether this is actually called `tl:ref` or something else (such
as a `tl:video`, `tl:audio`, `tl:script` etc) remains to be seen. It could even be
that there is no element as such but an attribute on an element in the host language (for
example `tl:timeAction="none|visibility|display|..."` as per HTML+SMIL). The `tl:prio`
is used by a `tl:par` parent (or actually closest `tl:par` ancestor) to
determine clock priorities and select the master clock. `tl:fill` is used by
the `tl:par` parent or ancestor to determine what to do when a non-master element
ends while the master element clock is still running: either pause it or remove it.

`<tl:par tl:end="first|all|master" tl:sync="true|false" tl:prio=... tl:fill=...>`

Parallel composition. All children run in parallel. The end of the `tl:par`
depends on the `tl:end` attribute: either when the first of its children has ended,
the last of its children has ended or its timeline master child has ended. We may
also want to specify a specific child (by xmlid) to determine when the `tl:par`
ends.

> *Note* (20160805): `tl:end="master"` may not be such a good idea. The master needs to be
computed dynamically (because it is used for clock synchronisation), but obviously
when the child-previously-known-as-master has stopped it is now no longer master.
Need to think about this a bit more.

`tl:sync` determines whether the children (except the master) are synchronised
to the `tl:par`, or whether they are free-running. The latter essentially creates
a completely independent timeline.

> It may be better to move the functionality of the `tl:sync` attribute to the child node,
so it is possible to easily specify that most children of a par are synchronised but
some are running on an independent timeline. Then we would get something like a
`tl:independent="true|false"` attribute. But it would only be allowed inside a
`tl:par` parent...

`<tl:seq>`

Sequential composition. The children run one after the other. 

> I think `tl:seq` should
not have the `tl:prio` and `tl:fill` attributes, but I am not quite sure.

`<tl:sleep tl:dur="10s" />`

Do nothing. Stop running after the given `tl:dur`.

`<tl:wait tl:event="...." />`

Do nothing. Stop running when the event happens. How this event is specified
(and whether we need the `tl:event` parameter in the first place) remains to
be seen, and probably depends on the host language. We also need to define when
the event listener is active:

- while the `<tl:wait>` is active,
- during the whole document lifetime (and maybe then we need an optional argument
to treat it like a counting semaphore?), or
- either, based on an optional argument.

`<tl:conditional tl:expr="...">`

Conditionally run the single child, based on whether `tl:expr` evaluates to true
or not. This may be better specified as an attribute (so we don't have this
_single child_ requirement). 

> Language for the expression is to be determined.

`<tl:switch>`

We may want the equivalent of the SMIL `<switch>` element. It would select the first
child (in document order) that is elegible and run that. So usually it would contain
a number of `<tl:conditional>` children followed by a single other child.

This element is generally used to select one of a number of alternatives, for example
based on language preference of the end user, or accessibility settings or something
similar. 

`<tl:excl>`

We may want some form of SMIL `<excl>` but this remains to be determined. The semantics
would be some form of priority-based pausing, but in SMIL the semantics were already
rather difficult to explain...

`<tl:repeat ...>`

We probably want some way to repeat things. It probably needs an optional count (defaulting
to infinite).

Recording State
---------------

To be able to save a document half-way through playing and restart it from that point
we need to be able to record the current state of document playback, so we can restart
later at the point where we left off. This will require a number of attributes
to record things like current clock position, number of repeats already executed, etc.

Recording state is also useful for debugging the timeline format execution engine.

For the 2immerse application, state is recorded in the following attributes:

- `tls:state="...."` the current execution state of the element. Can be 
`idle` (the default), `initing`, `inited`, `starting`, `started`, `finished`
or `stopping`. More states may be added later.
- Eventually we will need more attributes like `tls:position` and `tls:repeatCount`.

2immerse Specifics
------------------

The 2immerse-specific elements and attributes are flagged with the `tim:` namespace
identifier.

The `tl:ref` element is used to refer to media items, or DMApp Components in 2immerse
lingo. This may change to something like `<tim:dmappc tl:timed="true" ...>` at some
point in the future. It has a number of attributes:

- `tim:class` specifies the type of DMApp Component. Allowed names are to be decided.
- `tim:dmappcid` specifies the indentity of this instance of the DMApp Component.
At the moment I think that multiple instances sharing a name is allowed, these would then
be treated as multiple destinations of a single `tim:set` operation. But this may change.
- `tim:url` is the (optional) url to be passed to the DMApp Component initialize call,
to specify which media item should be played back.
- More `tim:` attributes will undoubtedly be added.

It may be needed to modify a DMApp Component that is already running, due to an event
or something like that. For this we could use a `<tim:set tim:dmappcid="...." ....>`
call. From a timeline point of view, a set behaves like an infinitely fast `tl:ref`
that does not need an `init()` call.

For the time being, `<tl:conditional>`, `<tl:excl>`, `<tl:switch>` and `<tl:repeat>`
have not been implemented.

At the moment, `tl:prio` has not been implemented, and the master clock of the whole
presentation is the broadcast video clock, where "broadcast video" is defined as the
`tl:ref` element with `tim:class="mastervideo"`.

Examples
--------

Various constructs become quite a bit more convoluted in this language than they
are in SMIL. First and foremost, not having `begin`, `dur` and `end` attributes means
that `<video begin="5s" dur="10s" .../>` will have to be encoded as

```
<tl:par tl:end="first">
  <tl:seq>
    <tl:sleep tl:dur="5s"/>
    <tl:video .../>
  </tl:seq>
  <tl:sleep tl:dur="10s"/>
</tl:par>
```

This is a nuisance from a coding point of view, but it has a great advantage for
the semantics. For example, it is absolutely clear that the "5s" is not with
respect to the video clock, and the 10s may be (depending on clock priorities).

API
---

There is going to be some sort of an API between the objects (at runtime),
specifically between parents and children. From parent to child, there will
be some sequence of `init()/start()/finish()/stop()/pause()/resume()`, and some
calls to modify clock relationships `slaveClockToMe()/becomeMasterClock()`.
There will be some callbacks from child to parent `inited()/started()/finished()/stopped()/paused()`
and some callbacks between clock master and clock slave `clockChanged()`.
There needs to be a call to get the current time of an element.

The states `started` and `finished` require a little explanation. A media item
that is `started` has its own internal timeline, and can be considered to be "running"
for some definition of the word. After some time, the underlying media object may
be over, and the media item goes to a state `finished`. In this state, the media
item no longer has a clock that can run (and hence it is no longer elegible to
be master clock) and the state of the item shouldn't change anymore without
external interference. This is similar to the SMIL `fill="freeze"` state.
Note that some media items, notably static text and images, will usually go straight
to `finished` in response to a `start()` call, because static media have no
concept of a clock.

For 2immerse, for the time being, `finish()` is not implemented (but the `finished` state is),
and neither are `pause()/paused()/resume()`.

Also for the time being, there is a single master clock that is driven from the clock
of the DMApp Component of type `mastervideo` (of which there should, therefore, only be one).
